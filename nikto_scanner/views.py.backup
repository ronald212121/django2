# FIXED: nikto_scanner/views.py - HANYA 2 PERBAIKAN KRITIS

# 1. FIX Cohere API parameter error
# 2. FIX NIKTO timeout handling  
# 3. FIX scoring logic untuk failed scans
# 4. ADDED: FIX Deduplication logic ‚úÖ
# 5. ADDED: FIX Severity classification ‚úÖ

from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.conf import settings
from django.core.cache import cache
import cohere
import json
import os
import re
import subprocess
import time
import requests
import logging
from datetime import datetime
from urllib.parse import urljoin, urlparse
from core.models import ScanResult

COHERE_API_KEY = "l5txUpFu1GUbXnR3fXLbbTt6wRchJi5c9A8SYDZd"

# ADDED: FIX DEDUPLICATION LOGIC ‚úÖ - IMPROVED VERSION
def deduplicate_vulnerabilities(vulnerabilities):
    """
    PERBAIKAN: Menghilangkan duplikasi berdasarkan type dan description
    IMPROVED: Logic yang lebih robust untuk deteksi duplikasi
    """
    seen = set()
    unique_vulns = []
    
    for vuln in vulnerabilities:
        # IMPROVED: Buat fingerprint yang lebih robust
        vuln_type = str(vuln.get('type', '')).strip().lower()
        vuln_desc = str(vuln.get('description', '')).strip().lower()
        
        # Bersihkan description dari karakter yang bisa berbeda
        vuln_desc_clean = re.sub(r'\s+', ' ', vuln_desc)  # Normalize whitespace
        vuln_desc_clean = vuln_desc_clean.replace(':', '').replace(',', '').replace('.', '')
        
        # IMPROVED: Gunakan kombinasi type + description yang sudah dibersihkan
        fingerprint = f"{vuln_type}||{vuln_desc_clean[:80]}"
        
        # DEBUG: Print untuk melihat fingerprint
        print(f"üîç CHECKING: {fingerprint}")
        
        if fingerprint not in seen:
            seen.add(fingerprint)
            unique_vulns.append(vuln)
            print(f"‚úÖ ADDED: {vuln_type} - {vuln_desc[:50]}...")
        else:
            print(f"üîÑ DEDUPLICATED: {vuln_type} - {vuln_desc[:50]}...")
    
    if len(vulnerabilities) != len(unique_vulns):
        print(f"üìä DEDUPLICATION SUCCESS: Reduced from {len(vulnerabilities)} to {len(unique_vulns)} items")
    else:
        print(f"‚ö†Ô∏è DEDUPLICATION: No duplicates found - all {len(vulnerabilities)} items are unique")
        # DEBUG: Print all fingerprints untuk analysis
        for i, vuln in enumerate(vulnerabilities):
            vuln_type = str(vuln.get('type', '')).strip().lower()
            vuln_desc = str(vuln.get('description', '')).strip().lower()
            vuln_desc_clean = re.sub(r'\s+', ' ', vuln_desc).replace(':', '').replace(',', '').replace('.', '')
            fingerprint = f"{vuln_type}||{vuln_desc_clean[:80]}"
            print(f"  {i+1}. {fingerprint}")
    
    return unique_vulns

class SecureSiteAwareScanner:
    """RESTORE: Scanner yang bisa detect SQL injection, XSS, dll"""
    
    def __init__(self, target_url, timeout=15):
        self.target_url = target_url
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def scan_all_vulnerabilities(self):
        """RESTORE: scan yang bisa detect SQL injection, XSS, dll"""
        print(f"üîç Starting security scan for {self.target_url}")
        
        vulnerabilities = []
        
        # Test for CRITICAL vulnerabilities first
        critical_vulns = self.scan_critical_vulnerabilities()
        vulnerabilities.extend(critical_vulns)
        
        # Test for other vulnerabilities
        other_vulns = self.scan_other_vulnerabilities()
        vulnerabilities.extend(other_vulns)
        
        # Test for positive features (minimal)
        security_features = self.scan_positive_security_features()
        vulnerabilities.extend(security_features)
        
        print(f"‚úÖ Security scan complete: {len(vulnerabilities)} items found")
        return vulnerabilities
    
    def scan_critical_vulnerabilities(self):
        """RESTORE: scan SQL injection, XSS, dll yang SUDAH BEKERJA"""
        vulns = []
        
        # Test SQL Injection
        sql_vulns = self.test_sql_injection()
        vulns.extend(sql_vulns)
        
        # Test XSS
        xss_vulns = self.test_xss_vulnerabilities()
        vulns.extend(xss_vulns)
        
        # Test Command Injection
        cmd_vulns = self.test_command_injection()
        vulns.extend(cmd_vulns)
        
        # Test File Upload
        upload_vulns = self.test_file_upload_vulnerabilities()
        vulns.extend(upload_vulns)
        
        return vulns
    
    def test_sql_injection(self):
        """RESTORE: test SQL injection yang SUDAH BEKERJA"""
        vulns = []
        
        sql_payloads = ["' OR '1'='1' --", "admin'--", "' OR 1=1 --"]
        login_endpoints = ['/login', '/admin/login', '/auth/login']
        
        for endpoint in login_endpoints:
            test_url = urljoin(self.target_url, endpoint)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200 and ('login' in response.text.lower() or 'username' in response.text.lower()):
                    
                    for payload in sql_payloads:
                        post_data = {'username': payload, 'password': payload}
                        post_response = self.session.post(test_url, data=post_data, timeout=self.timeout)
                        
                        # Check for SQL injection success indicators
                        success_indicators = ['welcome', 'dashboard', 'logged in', 'success', 'home']
                        error_indicators = ['sql syntax', 'mysql_fetch', 'database error', 'sqlite', 'postgresql']
                        
                        content_lower = post_response.text.lower()
                        
                        if (any(indicator in content_lower for indicator in success_indicators) or
                            any(indicator in content_lower for indicator in error_indicators)):
                            
                            vulns.append({
                                'type': 'SQL Injection',
                                'severity': 'critical',
                                'description': f'SQL injection vulnerability detected in login form at {endpoint}',
                                'path': endpoint,
                                'payload': payload,
                                'method': 'POST',
                                'evidence': 'Authentication bypass or SQL error detected',
                                'impact': 'Complete database compromise, authentication bypass, data theft',
                                'recommendation': 'Use parameterized queries/prepared statements immediately',
                                'cvss_score': 9.8,
                                'source': 'application_scanner'
                            })
                            print(f"üö® CRITICAL: SQL Injection found at {endpoint}")
                            return vulns  # Return immediately after finding one
                            
            except Exception as e:
                print(f"Error testing SQL injection on {test_url}: {e}")
        
        return vulns
    
    def test_xss_vulnerabilities(self):
        """RESTORE: test XSS yang SUDAH BEKERJA"""
        vulns = []
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        
        search_endpoints = ['/search', '/query', '/find']
        search_params = ['q', 'search', 'query', 'term']
        
        for endpoint in search_endpoints:
            test_url = urljoin(self.target_url, endpoint)
            
            try:
                for param in search_params:
                    for payload in xss_payloads:
                        response = self.session.get(
                            test_url,
                            params={param: payload},
                            timeout=self.timeout
                        )
                        
                        # Check if payload is reflected in response
                        if payload in response.text or payload.lower() in response.text.lower():
                            vulns.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'high',
                                'description': f'Reflected XSS vulnerability detected at {endpoint}',
                                'path': endpoint,
                                'parameter': param,
                                'payload': payload,
                                'method': 'GET',
                                'evidence': f'XSS payload reflected unescaped in response',
                                'impact': 'Session hijacking, credential theft, malicious content injection',
                                'recommendation': 'Implement proper input validation and output encoding',
                                'cvss_score': 8.1,
                                'source': 'application_scanner'
                            })
                            print(f"üö® HIGH: XSS vulnerability found at {endpoint}")
                            return vulns  # Return after finding one
                    
            except Exception as e:
                print(f"Error testing XSS on {test_url}: {e}")
        
        return vulns
    
    def test_command_injection(self):
        """RESTORE: test command injection yang SUDAH BEKERJA"""
        vulns = []
        
        cmd_payloads = ["; ls -la", "&& id", "| whoami", "; cat /etc/passwd"]
        cmd_endpoints = ['/ping', '/traceroute', '/nslookup', '/dig']
        cmd_params = ['host', 'target', 'ip', 'domain']
        
        for endpoint in cmd_endpoints:
            test_url = urljoin(self.target_url, endpoint)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200:
                    
                    for param in cmd_params:
                        for payload in cmd_payloads:
                            test_payload = f"google.com{payload}"
                            post_data = {param: test_payload}
                            post_response = self.session.post(test_url, data=post_data, timeout=self.timeout)
                            
                            # Check for command injection success
                            command_indicators = [
                                'uid=', 'gid=', 'total ', 'drwx', 'bin/', 'usr/', 'etc/', 'root:',
                                'www-data', 'apache', 'nginx', 'passwd', '/home/'
                            ]
                            
                            content = post_response.text.lower()
                            if any(indicator in content for indicator in command_indicators):
                                vulns.append({
                                    'type': 'Command Injection',
                                    'severity': 'critical',
                                    'description': f'Command injection vulnerability detected at {endpoint}',
                                    'path': endpoint,
                                    'parameter': param,
                                    'payload': test_payload,
                                    'method': 'POST',
                                    'evidence': 'System command output detected in response',
                                    'impact': 'Remote code execution, complete server compromise',
                                    'recommendation': 'Avoid system calls, use safe APIs, validate all input',
                                    'cvss_score': 9.9,
                                    'source': 'application_scanner'
                                })
                                print(f"üö® CRITICAL: Command Injection found at {endpoint}")
                                return vulns
                            
            except Exception as e:
                print(f"Error testing command injection on {test_url}: {e}")
        
        return vulns
    
    def test_file_upload_vulnerabilities(self):
        """RESTORE: test file upload yang SUDAH BEKERJA"""
        vulns = []
        
        upload_endpoints = ['/upload', '/file/upload', '/admin/upload']
        
        for endpoint in upload_endpoints:
            test_url = urljoin(self.target_url, endpoint)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200 and ('upload' in response.text.lower() or 'file' in response.text.lower()):
                    
                    # Test dangerous file upload
                    dangerous_content = '<?php system($_GET["cmd"]); ?>'
                    files = {'file': ('shell.php', dangerous_content, 'application/x-php')}
                    
                    upload_response = self.session.post(test_url, files=files, timeout=self.timeout)
                    
                    # Check for successful upload
                    success_indicators = ['uploaded', 'file saved', 'upload complete', 'successful', 'shell.php']
                    content = upload_response.text.lower()
                    
                    if any(indicator in content for indicator in success_indicators):
                        vulns.append({
                            'type': 'Unrestricted File Upload',
                            'severity': 'critical',
                            'description': f'Unrestricted file upload vulnerability at {endpoint}',
                            'path': endpoint,
                            'method': 'POST',
                            'evidence': 'Successfully uploaded potentially malicious PHP file',
                            'impact': 'Remote code execution, malware distribution, server compromise',
                            'recommendation': 'Implement strict file type validation and content scanning',
                            'cvss_score': 9.1,
                            'source': 'application_scanner'
                        })
                        print(f"üö® CRITICAL: File Upload vulnerability found at {endpoint}")
                        return vulns
                            
            except Exception as e:
                print(f"Error testing file upload on {test_url}: {e}")
        
        return vulns
    
    def scan_other_vulnerabilities(self):
        """RESTORE: scan vulnerability lainnya"""
        vulns = []
        
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            
            # Check for missing security headers
            missing_headers = []
            security_headers = ['X-Frame-Options', 'X-Content-Type-Options', 'X-XSS-Protection']
            
            for header in security_headers:
                if header not in response.headers:
                    missing_headers.append(header)
            
            if missing_headers:
                vulns.append({
                    'type': 'Missing Security Headers',
                    'severity': 'medium',
                    'description': f'Missing security headers: {", ".join(missing_headers)}',
                    'path': '/',
                    'method': 'GET',
                    'evidence': f'Headers not found: {", ".join(missing_headers)}',
                    'impact': 'Reduced protection against various attacks',
                    'recommendation': 'Implement missing security headers',
                    'cvss_score': 4.3,
                    'source': 'application_scanner'
                })
            
            # Check for server disclosure
            server_header = response.headers.get('Server', '')
            if server_header and ('/' in server_header or 'apache' in server_header.lower()):
                vulns.append({
                    'type': 'Server Information Disclosure',
                    'severity': 'low',
                    'description': 'Server version disclosed in headers',
                    'path': '/',
                    'method': 'GET',
                    'evidence': f'Server: {server_header}',
                    'impact': 'Information leakage for attackers',
                    'recommendation': 'Hide server version information',
                    'cvss_score': 2.1,
                    'source': 'application_scanner'
                })
                
        except Exception as e:
            print(f"Error scanning other vulnerabilities: {e}")
        
        return vulns
    
    def scan_positive_security_features(self):
        """RESTORE: scan positive features (minimal)"""
        security_features = []
        
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            
            # Check for ALL security headers
            security_headers = [
                'X-Frame-Options', 'X-Content-Type-Options', 'Strict-Transport-Security',
                'Content-Security-Policy', 'Referrer-Policy', 'X-XSS-Protection'
            ]
            
            present_headers = []
            for header in security_headers:
                if header in response.headers:
                    present_headers.append(header)
            
            # Only give positive if ALL headers present
            if len(present_headers) >= 6:
                security_features.append({
                    'type': 'Comprehensive Security Headers',  
                    'severity': 'info',
                    'description': f'Excellent security headers: {", ".join(present_headers)}',
                    'path': '/',
                    'method': 'GET',
                    'evidence': f'{len(present_headers)}/6 headers present',
                    'impact': 'POSITIVE: Strong security implementation',
                    'recommendation': 'Maintain current security configuration',
                    'cvss_score': 0.0,
                    'source': 'application_scanner',
                    'is_positive': True
                })
                print(f"‚úÖ POSITIVE: Comprehensive security headers detected")
                
        except Exception as e:
            print(f"Error scanning positive features: {e}")
        
        return security_features

# FIX 2: IMPROVED NIKTO scan dengan proper timeout handling
def run_traditional_nikto_scan(target, scan_type):
    """FIX 2: IMPROVED NIKTO scan dengan proper timeout dan retry"""
    
    if scan_type == 'basic':
        cmd = f"nikto -h {target} -timeout 10"
        timeout_seconds = 120  # Reduced timeout
    elif scan_type == 'full':
        cmd = f"nikto -h {target} -C all -timeout 15"
        timeout_seconds = 180  # Reduced timeout
    else:
        cmd = f"nikto -h {target} -timeout 8"
        timeout_seconds = 100
    
    try:
        print(f"üîß Running NIKTO command: {cmd}")
        print(f"‚è∞ Timeout set to: {timeout_seconds} seconds")
        
        process = subprocess.Popen(
            cmd, 
            shell=True,
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            text=True
        )
        
        stdout, stderr = process.communicate(timeout=timeout_seconds)
        
        if stdout and len(stdout.strip()) > 100:
            print(f"‚úÖ NIKTO completed successfully: {len(stdout)} characters output")
            return parse_nikto_output_restore(stdout)
        else:
            print("‚ö†Ô∏è NIKTO produced minimal output - likely no significant findings")
            return []
            
    except subprocess.TimeoutExpired:
        print(f"‚è∞ NIKTO scan timeout after {timeout_seconds} seconds")
        try:
            process.kill()
            process.wait()
        except:
            pass
        return []
    except Exception as e:
        print(f"‚ùå NIKTO scan error: {e}")
        return []

def parse_nikto_output_restore(output):
    """RESTORE: parse NIKTO yang SUDAH BEKERJA"""
    
    vulnerabilities = []
    lines = output.split('\n')
    
    for line in lines:
        if line.startswith('+ ') and len(line.strip()) > 15:
            description = line.replace('+ ', '').strip()
            
            # Skip only informational items
            skip_patterns = [
                'target ip:', 'target hostname:', 'target port:', 'start time:', 'end time:',
                'server:', 'no cgi directories', 'items checked:', 'host(s) tested'
            ]
            
            if any(pattern in description.lower() for pattern in skip_patterns):
                continue
            
            if len(description) > 10:
                severity = classify_nikto_severity_restore(description)
                
                vulnerability = {
                    'type': 'Infrastructure Finding',
                    'severity': severity,
                    'description': description,
                    'path': extract_path_from_nikto_line(line),
                    'source': 'nikto',
                    'recommendation': get_nikto_recommendation_enhanced(description)
                }
                
                vulnerabilities.append(vulnerability)
    
    print(f"üìä NIKTO produced {len(vulnerabilities)} findings")
    return vulnerabilities

# ADDED: FIX SEVERITY CLASSIFICATION ‚úÖ
def classify_nikto_severity_restore(description):
    """
    PERBAIKAN: Classification yang SUDAH BEKERJA dengan FIX untuk HTTP methods
    HANYA memperbaiki severity untuk HTTP methods normal
    """
    
    desc_lower = description.lower()
    
    # PERBAIKAN: HTTP methods normal seharusnya INFO, bukan MEDIUM/HIGH
    if 'allowed http methods' in desc_lower:
        # Check if it's only safe methods
        if all(method in desc_lower for method in ['head', 'options', 'get']) and 'post' not in desc_lower and 'put' not in desc_lower and 'delete' not in desc_lower:
            return 'info'  # Safe HTTP methods = INFO level
        else:
            return 'medium'  # Dangerous methods = MEDIUM level
    
    # High severity patterns (TIDAK DIUBAH)
    high_patterns = [
        'admin', 'config', 'backup', 'database', 'phpinfo',
        'server-status', 'server-info', 'test'
    ]
    
    # Medium severity patterns (TIDAK DIUBAH)
    medium_patterns = [
        'version', 'banner', 'disclosure', 'directory'
    ]
    
    if any(pattern in desc_lower for pattern in high_patterns):
        return 'high'  # RESTORE severity tinggi
    elif any(pattern in desc_lower for pattern in medium_patterns):
        return 'medium'  # RESTORE severity medium
    else:
        return 'low'

# ADDED: FIX DEDUPLICATION IN CLASSIFICATION ‚úÖ
def classify_vulnerabilities_by_severity_restore(vulnerabilities):
    """
    PERBAIKAN: Deduplication + classification yang SUDAH BEKERJA
    HANYA menambahkan deduplication di awal
    """
    
    # PERBAIKAN: Deduplicate vulnerabilities SEBELUM classification
    vulnerabilities = deduplicate_vulnerabilities(vulnerabilities)
    
    counts = {
        'critical': 0,
        'high': 0, 
        'medium': 0,
        'low': 0,
        'info': 0
    }
    
    for vuln in vulnerabilities:
        severity = vuln.get('severity', 'info').lower()
        is_positive = vuln.get('is_positive', False)
        
        # Count ALL vulnerabilities properly (TIDAK DIUBAH)
        if not is_positive and severity in counts:
            counts[severity] += 1
        elif is_positive:
            counts['info'] += 1  # Positive features as info
    
    print(f"üìä Classification Summary:")
    print(f"   üî¥ Critical: {counts['critical']}")
    print(f"   üü† High: {counts['high']}")
    print(f"   üü° Medium: {counts['medium']}")
    print(f"   üü¢ Low: {counts['low']}")
    print(f"   üìä Info: {counts['info']}")
    
    return counts

# FIX 3: IMPROVED scoring logic untuk failed scans
def run_nikto_scan(target, scan_type, user):
    """FIX 3: IMPROVED scan dengan proper scoring untuk failed scans"""
    
    print(f"üîç Starting NIKTO scan for {target}...")
    scan_start_time = time.time()
    
    # Initialize results
    all_vulnerabilities = []
    nikto_vulnerabilities = []
    app_vulnerabilities = []
    
    # Track scan failures
    nikto_scan_failed = False
    app_scan_failed = False
    
    # 1. Run traditional NIKTO scan
    try:
        print("üîß Running NIKTO infrastructure scan...")
        nikto_vulns = run_traditional_nikto_scan(target, scan_type)
        
        if nikto_vulns is None or len(nikto_vulns) == 0:
            print("‚ö†Ô∏è NIKTO scan returned no results - possible timeout or target unreachable")
            nikto_scan_failed = True
            nikto_vulnerabilities = []
        else:
            nikto_vulnerabilities = nikto_vulns
            all_vulnerabilities.extend(nikto_vulns)
            print(f"üìä NIKTO found {len(nikto_vulns)} infrastructure items")
        
    except Exception as e:
        print(f"‚ùå NIKTO scan failed: {e}")
        nikto_scan_failed = True
        nikto_vulnerabilities = []
    
    # 2. Run application scan
    try:
        print("üåê Running application vulnerability scan...")
        app_scanner = SecureSiteAwareScanner(target)
        app_vulns = app_scanner.scan_all_vulnerabilities()
        
        if app_vulns is None:
            print("‚ö†Ô∏è Application scan failed")
            app_scan_failed = True
            app_vulnerabilities = []
        else:
            app_vulnerabilities = app_vulns
            all_vulnerabilities.extend(app_vulns)
            print(f"üìä Application scan found {len(app_vulns)} items")
        
    except Exception as e:
        print(f"‚ùå Application scan failed: {e}")
        app_scan_failed = True
        app_vulnerabilities = []
    
    # üîß PERBAIKAN: DEDUPLICATE all_vulnerabilities SETELAH semua scan selesai
    print(f"üìä Before deduplication: {len(all_vulnerabilities)} total items")
    all_vulnerabilities = deduplicate_vulnerabilities(all_vulnerabilities)
    print(f"üìä After deduplication: {len(all_vulnerabilities)} unique items")
    
    scan_duration = time.time() - scan_start_time
    
    # 3. Create comprehensive result with failure tracking
    result = {
        'scan_successful': not (nikto_scan_failed and app_scan_failed),
        'nikto_scan_failed': nikto_scan_failed,
        'app_scan_failed': app_scan_failed,
        'target': target,
        'scan_type': scan_type,
        'total_findings': len(all_vulnerabilities),
        'nikto_findings': len(nikto_vulnerabilities),
        'application_findings': len(app_vulnerabilities),
        'vulnerabilities': all_vulnerabilities,
        'nikto_vulnerabilities': nikto_vulnerabilities,
        'application_vulnerabilities': app_vulnerabilities,
        'scan_duration': f"{scan_duration:.2f} seconds",
        'scan_timestamp': datetime.now().isoformat(),
        'enhancement': 'FIXED_scan_failure_handling'
    }
    
    # 4. Use FIXED vulnerability classification (dengan deduplication)
    vulnerability_stats = classify_vulnerabilities_by_severity_restore(all_vulnerabilities)
    
    print(f"üéØ Scan Results:")
    print(f"   üìä Total items: {len(all_vulnerabilities)}")
    print(f"   üèóÔ∏è  Infrastructure: {len(nikto_vulnerabilities)}")
    print(f"   üåê Application: {len(app_vulnerabilities)}")
    print(f"   üî¥ Critical: {vulnerability_stats['critical']}")
    print(f"   üü† High: {vulnerability_stats['high']}")
    print(f"   üü° Medium: {vulnerability_stats['medium']}")
    print(f"   üü¢ Low: {vulnerability_stats['low']}")
    print(f"   üìä Info: {vulnerability_stats['info']}")
    
    # 5. Store scan result dengan failure penalty
    try:
        scan_result = ScanResult(
            user=user,
            target=target,
            tool='nikto',
            scan_type=f"{scan_type}_universal",
            result=json.dumps(result, default=str, indent=2),
            low_count=vulnerability_stats['low'],
            medium_count=vulnerability_stats['medium'],
            high_count=vulnerability_stats['high'],
            critical_count=vulnerability_stats['critical'],
            info_count=vulnerability_stats['info']
        )
        scan_result.save()
        
        # FIX 3: IMPROVED security score dengan failure penalty
        base_security_score = scan_result.get_security_score()
        
        # Apply failure penalty
        if nikto_scan_failed and app_scan_failed:
            # Both scans failed - major penalty
            adjusted_score = max(10, base_security_score - 40)
            print(f"‚ö†Ô∏è MAJOR FAILURE PENALTY: Both scans failed")
        elif nikto_scan_failed:
            # NIKTO scan failed - moderate penalty
            adjusted_score = max(20, base_security_score - 25)
            print(f"‚ö†Ô∏è NIKTO FAILURE PENALTY: Infrastructure scan failed")
        elif app_scan_failed:
            # App scan failed - minor penalty
            adjusted_score = max(30, base_security_score - 15)
            print(f"‚ö†Ô∏è APP FAILURE PENALTY: Application scan failed")
        else:
            # No failures
            adjusted_score = base_security_score
        
        # Override the score calculation for display
        scan_result._failure_adjusted_score = adjusted_score
        
        risk_level = scan_result.get_risk_level()
        
        print(f"üìä Security Score: {adjusted_score}/100 (base: {base_security_score}, adjusted for failures)")
        print(f"üìä Risk Level: {risk_level}")
        print(f"üíæ Scan result saved - ID: {scan_result.id}")
        
        return scan_result
        
    except Exception as save_error:
        print(f"‚ùå Error saving scan result: {save_error}")
        return None

# FIX 1: FIXED Cohere client tanpa parameter 'model'
class FixedCohereClient:
    """FIX 1: FIXED Cohere client - menghapus parameter 'model' yang menyebabkan error"""
    
    def __init__(self):
        self.client = cohere.Client(COHERE_API_KEY)
        self.max_retries = 3
        
    def generate_recommendation_with_retry(self, prompt, scan_id=None):
        """FIX 1: Generate recommendation tanpa parameter 'model'"""
        
        for attempt in range(self.max_retries):
            try:
                print(f"ü§ñ Cohere attempt {attempt + 1}/{self.max_retries}")
                
                # FIX 1: HAPUS parameter 'model' yang menyebabkan error
                response = self.client.generate(
                    prompt=prompt,
                    max_tokens=1500,
                    temperature=0.1,
                    k=0,
                    stop_sequences=[],
                    return_likelihoods='NONE'
                    # REMOVED: model parameter yang menyebabkan error!
                )
                
                if not response.generations:
                    raise Exception("No response generated from Cohere")
                
                generated_text = response.generations[0].text.strip()
                
                if len(generated_text) > 50:
                    print(f"‚úÖ Cohere response received: {len(generated_text)} characters")
                    return generated_text
                else:
                    print(f"‚ö†Ô∏è Short response, retrying... (attempt {attempt + 1})")
                    if attempt < self.max_retries - 1:
                        time.sleep(1)
                        continue
                    else:
                        return generated_text + "\n\n*[Response may be incomplete]*"
                
            except Exception as e:
                error_msg = str(e)
                print(f"‚ùå Cohere error on attempt {attempt + 1}: {error_msg}")
                
                # Check if it's the model parameter error
                if "unknown field" in error_msg and "model" in error_msg:
                    print("üîß Detected model parameter error - this should be fixed now")
                
                if attempt < self.max_retries - 1:
                    delay = 2 ** attempt
                    print(f"‚è≥ Retrying in {delay} seconds...")
                    time.sleep(delay)
                else:
                    print(f"‚ùå All Cohere attempts failed after {self.max_retries} tries")
                    return self.generate_fallback(scan_id)
        
        return self.generate_fallback(scan_id)
    
    def generate_fallback(self, scan_id):
        """Generate fallback when Cohere fails"""
        return """
ü§ñ **SECURITY ANALYSIS - AI Service Issue**

**IMMEDIATE ACTIONS:**
‚Ä¢ Review any critical or high-severity vulnerabilities immediately
‚Ä¢ Address missing security controls per industry standards
‚Ä¢ Implement essential security headers and protections

**RECOMMENDATIONS:**
‚Ä¢ Regular security assessments and monitoring
‚Ä¢ Comprehensive vulnerability management program
‚Ä¢ Compliance with relevant security frameworks

*AI analysis temporarily unavailable - please review scan results manually.*
        """

@login_required
def nikto_scan_view(request):
    """RESTORE: scan view yang SUDAH BEKERJA dengan 3 FIXES"""
    
    if request.method == 'POST':
        target = request.POST.get('target', '').strip()
        scan_type = request.POST.get('scan_type', 'basic')
        
        # Enhanced input validation
        if not target:
            messages.error(request, "Target URL is required for NIKTO scanning.")
            return render(request, 'nikto_scanner/scan_form.html')
        
        # Basic URL validation
        if not target.startswith(('http://', 'https://')):
            messages.error(request, "Target must start with http:// or https://")
            return render(request, 'nikto_scanner/scan_form.html')
        
        try:
            print(f"üîç Starting NIKTO scan for {target}")
            
            # Run FIXED NIKTO scan (dengan 3 fixes + deduplication + severity fix)
            scan_result = run_nikto_scan(target, scan_type, request.user)
            
            if not scan_result:
                messages.error(request, "Scan failed to complete. Please check target accessibility.")
                return render(request, 'nikto_scanner/scan_form.html')
            
            # FIX 1: Generate AI recommendations dengan FIXED Cohere client
            print("ü§ñ Generating AI recommendations...")
            
            try:
                enhanced_prompt = generate_cohere_prompt(scan_result, target, scan_type)
                
                # Use FIXED Cohere client (tanpa parameter model)
                cohere_client = FixedCohereClient()
                enhanced_recommendation = cohere_client.generate_recommendation_with_retry(
                    enhanced_prompt, 
                    scan_id=scan_result.id
                )
                
                # Save the recommendation
                scan_result.recommendation = enhanced_recommendation
                scan_result.save()
                print("‚úÖ AI recommendation generated and saved successfully")
                
            except Exception as e:
                print(f"‚ùå Cohere Error: {str(e)}")
                scan_result.recommendation = "AI service temporarily unavailable. Please review scan results manually."
                scan_result.save()
                messages.warning(request, "AI service temporarily unavailable.")
            
            # Success messages dengan failure-aware scoring
            base_score = scan_result.get_security_score()
            adjusted_score = getattr(scan_result, '_failure_adjusted_score', base_score)
            risk_level = scan_result.get_risk_level()
            total_vulns = scan_result.get_total_vulnerabilities()
            
            # Check for scan failures
            result_data = json.loads(scan_result.result)
            nikto_failed = result_data.get('nikto_scan_failed', False)
            app_failed = result_data.get('app_scan_failed', False)
            
            if nikto_failed or app_failed:
                failure_msg = []
                if nikto_failed:
                    failure_msg.append("NIKTO infrastructure scan")
                if app_failed:
                    failure_msg.append("application vulnerability scan")
                
                messages.warning(request, 
                    f"‚ö†Ô∏è Partial scan failure: {' and '.join(failure_msg)} failed. Score adjusted to {adjusted_score}/100")
            
            if total_vulns == 0:
                messages.success(request, 
                    f"üõ°Ô∏è No vulnerabilities detected. Score: {adjusted_score}/100, Risk: {risk_level}")
            elif scan_result.critical_count > 0 or scan_result.high_count > 0:
                messages.warning(request, 
                    f"‚ö†Ô∏è {total_vulns} vulnerabilities found including {scan_result.critical_count} critical and {scan_result.high_count} high severity. Score: {adjusted_score}/100")
            else:
                messages.info(request, 
                    f"‚ÑπÔ∏è {total_vulns} minor security issues found. Score: {adjusted_score}/100, Risk: {risk_level}")
            
            return redirect('scan_result', scan_id=scan_result.id)
        
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå Scan error: {error_msg}")
            
            if "Connection" in error_msg or "timeout" in error_msg.lower():
                messages.error(request, f"Connection error: Unable to reach target {target}.")
            else:
                messages.error(request, f"Scan failed: {error_msg}")
    
    # Render form
    context = {
        'scan_types': [
            ('basic', 'FIXED Basic Scan - SQL injection, XSS detection with improved timeout (2-3 minutes)'),
            ('full', 'FIXED Full Scan - Comprehensive security scan with failure handling (5-8 minutes)'),
        ],
        'enhancement_info': {
            'enabled': True,
            'features': [
                'FIX 1: Cohere AI integration (removed model parameter)',
                'FIX 2: Improved NIKTO timeout handling',
                'FIX 3: Scoring logic penalizes scan failures',
                'FIX 4: ADDED Deduplication logic ‚úÖ',
                'FIX 5: ADDED Severity classification fix ‚úÖ',
                'RESTORED SQL Injection detection',
                'RESTORED XSS vulnerability detection', 
                'RESTORED Command Injection detection',
                'RESTORED File Upload vulnerability detection'
            ]
        }
    }
    
    return render(request, 'nikto_scanner/scan_form.html', context)

def generate_cohere_prompt(scan_result, target, scan_type):
    """Generate enhanced Cohere prompt"""
    
    # Get scores
    base_score = scan_result.get_security_score()
    adjusted_score = getattr(scan_result, '_failure_adjusted_score', base_score)
    risk_level = scan_result.get_risk_level()
    total_vulns = scan_result.get_total_vulnerabilities()
    
    # Check for failures
    result_data = json.loads(scan_result.result)
    scan_failures = []
    if result_data.get('nikto_scan_failed', False):
        scan_failures.append("NIKTO infrastructure scan failed")
    if result_data.get('app_scan_failed', False):
        scan_failures.append("Application scan failed")
    
    prompt = f"""
**SECURITY ASSESSMENT RESULTS**

Target: {target}
Security Score: {adjusted_score}/100 (Base: {base_score}/100)
Risk Level: {risk_level}
Total Vulnerabilities: {total_vulns}

**VULNERABILITY BREAKDOWN:**
- Critical: {scan_result.critical_count}
- High: {scan_result.high_count}  
- Medium: {scan_result.medium_count}
- Low: {scan_result.low_count}
- Info: {scan_result.info_count}
"""

    if scan_failures:
        prompt += f"""
**SCAN ISSUES:**
{chr(10).join(f"- {failure}" for failure in scan_failures)}
Score was adjusted down due to incomplete scan coverage.
"""

    prompt += """
Provide comprehensive security recommendations for this target, focusing on the most critical issues first.
"""
    
    return prompt

# Helper functions
def extract_path_from_nikto_line(line):
    """Extract path from NIKTO finding"""
    path_match = re.search(r'(/[^\s,\)]*)', line)
    return path_match.group(1) if path_match else '/'

def get_nikto_recommendation_enhanced(description):
    """Get enhanced recommendation for NIKTO finding"""
    desc_lower = description.lower()
    
    recommendations = {
        'admin': 'Secure admin interfaces with strong authentication and access controls',
        'config': 'Remove or secure configuration files from web-accessible directories',
        'version': 'Hide server version information to prevent fingerprinting',
        'backup': 'Remove backup files from web-accessible locations',
        'database': 'Ensure database files are not accessible via web',
        'phpinfo': 'Remove phpinfo() pages from production servers',
        'server-status': 'Disable server status pages in production',
        'server-info': 'Disable server info pages in production'
    }
    
    for keyword, recommendation in recommendations.items():
        if keyword in desc_lower:
            return recommendation
    
    return 'Review and secure the identified issue according to security best practices'